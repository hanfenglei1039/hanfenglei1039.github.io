<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[note_xxxx]]></title>
    <url>%2F2018%2F07%2F08%2Fkaikeba_QUESTION%2F</url>
    <content type="text"><![CDATA[kaikeba ###]]></content>
  </entry>
  <entry>
    <title><![CDATA[kaikeba_0702]]></title>
    <url>%2F2018%2F07%2F07%2Fkaikeba_0702%2F</url>
    <content type="text"><![CDATA[kaikeba ###]]></content>
  </entry>
  <entry>
    <title><![CDATA[kaikeba_0706]]></title>
    <url>%2F2018%2F07%2F07%2Fkaikeba_0706%2F</url>
    <content type="text"><![CDATA[kaikeba ###]]></content>
  </entry>
  <entry>
    <title><![CDATA[kaikeba_xxxx]]></title>
    <url>%2F2018%2F07%2F07%2Fkaikeba_0000%2F</url>
    <content type="text"><![CDATA[kaikeba ###]]></content>
  </entry>
  <entry>
    <title><![CDATA[kaikeba_0704]]></title>
    <url>%2F2018%2F07%2F07%2Fkaikeba_0704%2F</url>
    <content type="text"><![CDATA[kaikeba no-repeat1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .nihao &#123; width: 300px; height: 200px; background-color: green; border: 20px dashed red; background: url("2.jpg"); margin-bottom: 20px; &#125; .han &#123; width: 300px; height: 200px; background-color: green; border: 20px dashed red; /* 有no-repeat，在边框的下面不会有图片 */ background: url("2.jpg") no-repeat; /* 字体会变色 */ color: blue; /* padding部分也显示图片， 字围效果，图片从边框坐上角显示，但是文字会在padding后的未知显示 */ padding: 20px; /* 设置图片从哪里开始显示 */ /* 图片从边框左上角的位置显示 */ /* background-origin: border-box; */ /* 图片从内边距的位置显示 */ /* background-origin: padding-box; */ /* 图片从内容的位置显示 */ /* background-origin: content-box; */ /* 设置图片在哪里显示 */ /* background-clip: border-box; */ /* background-clip: padding-box; */ /* background-clip: content-box; */ /* 显示完整图片，padding处也显示 */ /* background-size: contain; */ /* 边框填满为止 */ background-size: conver; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="nihao"&gt;hhhh, woyou bianshuaile&lt;/div&gt; &lt;div class="han"&gt;hhhh, woyou bianshuaile&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 伪元素、伪类1: 与 ::的区别 魔方如何进行鼠标拖动旋转, (3D展示)]]></content>
  </entry>
  <entry>
    <title><![CDATA[kaikeba_0629]]></title>
    <url>%2F2018%2F07%2F03%2Fkaikeba_0629%2F</url>
    <content type="text"><![CDATA[kaikeba novalidate与required12Q:如果form设置了 novalidate, 但是在input中又设置了required, 哪个权重大?A:我的测试结果是:novalidate生效 box-sizing:border-box1234567.tabs &#123; width: 400px; margin: 30px auto; background-color: #FFF; border: 1px solid #C0DCC0; box-sizing: border-box; //-------------&gt;&#125; display:flex12345678.tabs nav &#123; height: 40px; text-align: center; line-height: 40px; overflow: hidden; background-color: #C0DCC0; display: flex; //-------------&gt;&#125; text-decoration:none1234567nav a &#123; display: block; width: 100px; border-right: 1px solid #FFF; color: #000; text-decoration: none; //-------------&gt;&#125; 自定义属性123456789101112131415161718192021222324252627自定义属性--13自定义属性案例(function (key) &#123; //获取所有的a标签,判断有没有a标签应用了类样式 var aObjs = document.querySelectorAll("nav a"); for (var i = 0; i &lt; aObjs.length; i++) &#123; //判断a标签是否应用了类样式 if (!aObjs[i].classList.contains("active")) &#123; //设置默认的第一个a标签应用类样式,同时找到a对应的section显示出来 aObjs[key].classList.add("active"); //获取第一个a标签的自定义属性的值 var attr = aObjs[key].dataset["cont"]; //attr作为id属性值获取对应的section元素 document.getElementById(attr).style.display = "block"; &#125; //为每个a注册点击事件 aObjs[i].onclick = function () &#123; //找到应用了active的a,干掉这个类样式,干掉这个a对应的section的样式 var active = document.querySelector(".active"); active.classList.remove("active"); document.getElementById(active.dataset["cont"]).style.display = "none"; //当前被点击的a应用类样式.同时设置对应section显示 this.classList.add("active"); document.getElementById(this.dataset.cont).style.display = "block"; &#125;; &#125;&#125;)(0); 读取本地图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv = "X-UA-Compatible" content = "IE=edge,chrome=1" /&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" /&gt;&lt;title&gt;html5camera&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="main"&gt; &lt;div class="demo"&gt; &lt;p&gt; &lt;label&gt;请选择一个图像文件(请使用高级浏览器浏览：如Chrome，Firefox)：&lt;/label&gt;&lt;br&gt; &lt;input type="file" id="file_input" /&gt; &lt;/p&gt; &lt;div id="result"&gt; &lt;!-- 这里用来显示读取结果 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;br/&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var result = document.getElementById("result"); var input = document.getElementById("file_input"); if(typeof FileReader === 'undefined')&#123; result.innerHTML = "抱歉，你的浏览器不支持 FileReader"; input.setAttribute('disabled','disabled'); &#125;else&#123; input.addEventListener('change',readFile,false); &#125; function readFile()&#123; var file = this.files[0]; if(!/image\/\w+/.test(file.type))&#123; alert("请确保文件为图像类型"); return false; &#125; var reader = new FileReader(); reader.readAsDataURL(file); reader.onload = function(e)&#123; //alert(3333) //alert(this.result); result.innerHTML = '&lt;img src="'+this.result+'" alt=""/&gt;' &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[.gitignore规则]]></title>
    <url>%2F2018%2F05%2F03%2Fgitignore%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[.gitignore文件语法 123456"#"号 为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt .gitignore规则不生效的解决办法12345把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：git rm -r --cached .git add .git commit -m 'update .gitignore']]></content>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F05%2F03%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git常用命令 git库简介 Workspace: 工作区 Index/Stage: 暂存区 Repository：本地仓库 Remote： 远程仓库 新建代码库12345678# 在当前目录新建一个git代码库$ git init# 新建一个目录, 将其初始化为git代码库$ git init [projec-name]# 下载一个项目和它的这个代码历史$ git clone [url] 配置123456789# 显示当前的git配置$ git config --list# 编辑git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" 增加/删除文件1234567891011121314151617# 添加制定文件到暂存区git add [file1] [file2] ...# 添加制定目录到暂存区, 包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前, 都会要求确认, 对于同一个文件的多处变化, 可以实现分次提交$ git add -p# 删除工作区文件, 并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件, 但改文件会保留在工作区$ git mv [file-original] [file-renamed] 提交代码1234567891011121314151617# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指点文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化, 直接到仓库区$ git commit -a# 提交时显示所有的diff信息$ git commit -v# 使用一次新的commit, 替代上一次提交, 如果代码没有任何新变化, 则用来改写上一次的commit的提交信息$ git commit --amend -m [message]# 重做上一次commit, 并包括制定文件到新文件$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地和远程分支$ git branch -a# 新建一个分支, 但依旧留在当前分支$ git branch [branch-name]# 新建一个分支, 并切换到该分支$ git checkout -b [branch-name]# 新建一个分支, 指向指定commit$ git branch [branch] [conmmit]# 新建一个分支, 与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支, 并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 在现有的分支与指定的远程分支之间, 建立追踪关系$ git branch --set -upstrem [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit, 合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive]]></content>
  </entry>
  <entry>
    <title><![CDATA[mypub]]></title>
    <url>%2F2018%2F05%2F02%2Fmypub%2F</url>
    <content type="text"><![CDATA[常用函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394import &#123; timingSafeEqual &#125; from 'crypto';var moment = require('moment');var util = require('util');var dbhd = require('./dboper');var basic = require('./basic');var mqhd = require('./mqoper');require('./errorRecord');const ONE_MINUTE_MILL_SECONDS = 1000 * 60;const ONE_HOUR_MILL_SECONDS = ONE_MINUTE_MILL_SECONDS * 60;const ONE_DAY_MILL_SECONDS = ONE_HOUR_MILL_SECONDS * 24;const ONE_WEEK_MILL_SECONDS = ONE_DAY_MILL_SECONDS * 7;const ONE_YEAR_MILL_SECONDS = ONE_DAY_MILL_SECONDS * 365;const ERR_RESULT_SUCCESS = "success";const ERR_RESULT_FAIL = "fail";const ERR_RESULT_BIG_SUCCESS = "SUCCESS";const ERR_RESULT_BIG_FAIL = "FAIL";var ERR_CODE_PARAM = 1;var ERR_CODE_PUB = 2;function json2str(jsonData) &#123; return JSON.stringify(jsonData);&#125;function print(data) &#123; return util.inspect(data, &#123; depth: null &#125;);&#125;function getZeroTimeNumYesterday() &#123; var dateTime = new Date(); var zeroTimeYesterday = new Date(dateTime.toDateString()) - ONE_DAY_MILL_SECONDS; return zeroTimeYesterday;&#125;function getZeroTimeNumToday() &#123; var dateTime = new Date(); var zeroTimeToday = +new Date(dateTime.toDateString()); return zeroTimeToday;&#125;function isNum(param) &#123; return Object.prototype.toString.call(param) === "[object Number]";&#125;function isString(param) &#123; return Object.prototype.toString.call(param) === "[object String]";&#125;function isUndefined(param) &#123; return Object.prototype.toString.call(param) === "[object Undefined]";&#125;function isBoolean(param) &#123; return Object.prototype.toString.call(param) === "[object Boolean]";&#125;function isObject(param) &#123; return Object.prototype.toString.call(param) === "[object Object]";&#125;function isArray(param) &#123; return Object.prototype.toString.call(param) === "[object Array]";&#125;function isFunction(param) &#123; return Object.prototype.toString.call(param) === "[object Function]";&#125;function indexOf(array, val) &#123; for (var i = 0; i &lt; array.length; i++) &#123; if (array[i] == val) &#123; return i; &#125; &#125; return -1;&#125;function removeArrya(array, val) &#123; var index = indexOf(array, val); if (-1 != index) &#123; array.splice(index, 1); &#125; return array;&#125;function removeArrSpecifyObj(array, key, val) &#123; array.map( function(item, index) &#123; var flag = item[key] == val ? true : false; if (true == flag) &#123; array.splice(index, 1); &#125; &#125; ); return array;&#125;function uniqueArray(array) &#123; var obj = &#123;&#125;; var res = []; array.forEach(function(item) &#123; if (!obj[item]) &#123; obj[item] = true; res.push(item); &#125; &#125;); return res;&#125;function compare(sortName) &#123; return function(o, p) &#123; var a = &#123;&#125;; var b = &#123;&#125;; if (isObject(o) &amp;&amp; isObject(p) &amp;&amp; o &amp;&amp; p) &#123; a = o[sortName]; b = p[sortName]; &#125; if (a === b) &#123; return 0; &#125; if (typeof a === typeof b) &#123; return (a &lt; b) ? -1 : 1; &#125; return (typeof a &lt; typeof b) ? -1 : 1; &#125;&#125;function stampToday() &#123; var today = moment().startOf("day"); var timestamp = []; timestamp.push(today.format("YYYY-MM-DD HH:00:00")); for (var i = 0; i &lt; 24; i++) &#123; timestamp.push(today.add(1, "hours").format("YYYY-MM-DD HH:00:00")); &#125; return timestamp;&#125;function stampLast1Day() &#123; var from = moment().subtract(1, "days"); var timestamp = []; timestamp.push(from.format("YYYY-MM-DD HH:00:00")); for (var i = 0; i &lt; 24; i++) &#123; timestamp.push(from.add(1, "hours").format("YYYY-MM-DD HH:00:00")); &#125; return timestamp;&#125;function stampLastNumDays(dayNum) &#123; var from = moment().subtract(dayNum, "days"); var timestamp = []; timestamp.push(from.format("YYYY-MM-DD")); for (var i = 0; i &lt; dayNum; i++) &#123; timestamp.push(from.add(1, "days").format("YYYY-MM-DD")); &#125; return timestamp;&#125;function stampLast1Year() &#123; var from = moment().subtract(1, "years"); var timestamp = []; timestamp.push(from.format("YYYY-MM")); for (var i = 0; i &lt; 12; i++) &#123; timestamp.push(from.add(1, "months").format("YYYY-MM")); &#125; return timestamp;&#125;function stampThisHour(step) &#123; var from = moment().startOf("hour"); var timestamp = []; var count = 60 / step; timestamp.push(from.format("YYYY-MM-DD HH:mm:00")); for (var i = 0; i &lt; count; i++) &#123; timestamp.push(from.add(step, "minutes").format("YYYY-MM-DD HH:mm:00")); &#125; return timestamp;&#125;function stampLast1Hour(step) &#123; var from = moment().subtract(1, "hour"); var timestamp = []; var count = 60 / step; timestamp.push(from.format("YYYY-MM-DD HH:mm:00")); for (var i = 0; i &lt; count; i++) &#123; timestamp.push(from.add(step, "minutes").format("YYYY-MM-DD HH:mm:00")); &#125; return timestamp;&#125;function stampBeforeDays(dayBefore, daysNum) &#123; var talBefore = dayBefore + daysNum; var from = moment().subtract(talBefore, "days"); var timestamp = []; timestamp.push(from.format("YYYY-MM-DD")); for (var i = 1; i &lt; daysNum; i++) &#123; timestamp.push(from.add(1, "days").format("YYYY-MM-DD")); &#125; return timestamp;&#125;function stampBeforeHours(hoursBefore, hoursNum) &#123; var talBefore = hoursBefore + hoursNum; var from = moment().subtract(talBefore, "hours"); var timestamp = []; timestamp.push(from.format("YYYY-MM-DD HH")); for (var i = 1; i &lt; hoursNum; i++) &#123; timestamp.push(from.add(1, "days").format("YYYY-MM-DD HH")); &#125; return timestamp;&#125;function stampYesterday() &#123; var nCurHour = (new Date()).getHours(); return stampBeforeHours(Number(nCurHour), 24);&#125;function lastHours(hours) &#123; var from = moment().subtract(hours, "hours"); var timestamp = []; for (var i = 0; i &lt; hours; i++) &#123; timestamp.push(from.add(1, "hours").format("YYYY-MM-DD HH:00:00")); &#125; return timestamp;&#125;function lastMinutess(mins) &#123; var from = moment().subtract(mins, "minutes"); var timestamp = []; for (var i = 0; i &lt; mins; i++) &#123; timestamp.push(from.add(1, "minutes").format("YYYY-MM-DD HH:mms:00")); &#125; return timestamp;&#125;function getStamps(timeId) &#123; var times = []; switch (timeId) &#123; case "thisHour": &#123; times = stampThisHour(5); break; &#125; case "lastHour": &#123; times = stampLast1Hour(5); break; &#125; case "lastDay": &#123; times = stampLast1Day(); break; &#125; case "yesterday": &#123; times = stampYesterday(); break; &#125; case "today": &#123; times = stampToday(); break; &#125; case "last7Days": &#123; times = stampLastNumDays(7); break; &#125; case "last15Days": &#123; times = stampLastNumDays(15); break; &#125; case "last30Days": &#123; times = stampLastNumDays(30); break; &#125; case "lastYear": &#123; times = stampLast1Year(); break; &#125; default: &#123; console.error("error"); &#125; return times; &#125;&#125;function successV1(oData, key1, value1, key2, value2) &#123; var oResponse = &#123; result: ERR_RESULT_BIG_SUCCESS &#125;; if (null != oData) &#123; oResponse.message = oData; &#125; if (null != key1 &amp;&amp; null != value1) &#123; oResponse[key1] = value1; &#125; if (null != key2 &amp;&amp; null != value2) &#123; oResponse[key2] = value2; &#125; return oResponse;&#125;function failV1(sFileName, nLineNum, sReason, nErrorCode) &#123; var oResponse = &#123; result: ERR_RESULT_BIG_FAIL &#125;; if (null != sFileName || null != nLineNum || null != sReason || null != nErrorCode) &#123; oResponse.message = &#123;&#125;; &#125; if (null != sFileName) &#123; oResponse.message.errorFile = sFileName; &#125; if (null != nLineNum) &#123; oResponse.message.errorNum = nLineNum; &#125; if (null != sReason) &#123; oResponse.message.errorReason = sReason; &#125; if (null != nErrorCode) &#123; oResponse.message.errorCode = nErrorCode; &#125; return oResponse;&#125;function judgeObjLenIsZero(jsonData) &#123; return (0 == Object.keys(jsonData).length) ? true : false;&#125;function getObjLen(jsonData) &#123; return Object.keys(jsonData).length;&#125;function getObjKeys(jsonData) &#123; return Object.keys(jsonData).length;&#125;function getObjVals(jsonData) &#123; return Object.values(jsonData);&#125;// var nowTime = new Date().myFormat("yyyy-MM-dd hh:mm:ss");Date.prototype.myFormat = function (fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, "d+": this.getDate(), "h+": this.getHours(), "m+": this.getMinutes(), "s+": this.getSeconds(), "q+": Math.floor((this.getMonth() + 3) / 3), "S" : this.getMilliseconds() &#125;; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace( RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length) ); &#125; for (var k in o) &#123; if (new RegExp("(" + k + ")").test(fmt)) &#123; fmt = fmt.replace( RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)) ); &#125; &#125; return fmt;&#125;function judgeCb (cb) &#123; return (cb &amp;&amp; isFunction(cb));&#125;function judgeParam (oBody, sParam, oReturn) &#123; if (null == oReturn || undefined == oReturn) &#123; return (oBody.hasOwnProperty(sParam) ? oBody[sParam] : null); &#125; else &#123; return (oBody.hasOwnProperty(sParam) ? oBody[sParam] : oReturn); &#125;&#125;function judgeMongoRtn(aData) &#123; var aTemp = isArray(aData) ? aData : []; if ((0 != aTemp.length) &amp;&amp; (isObject(aTemp[0]))) &#123; return true; &#125; else &#123; return false; &#125;&#125;function getCurMillTime() &#123; return Number(+(new Date()));&#125; 本站访客数: 本站总访问量次]]></content>
  </entry>
  <entry>
    <title><![CDATA[.eslintrc.js]]></title>
    <url>%2F2018%2F05%2F02%2Feslintrc-js%2F</url>
    <content type="text"><![CDATA[.eslintrc.js常用配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344module.exports = &#123; "env": &#123; "browser": true, "node": true &#125;, "extends": "eslint:recommended", "parserOptions": &#123; "ecmaVersion": 6 &#125;, "rules": &#123; "no-console": 0, //禁止使用console "default-case": 2, //switch语句最后必须有default "no-magic-numbers": [1, &#123; "ignore": [0, -1, 1] &#125;], //没有魔鬼数字, 0, 1, -1忽略 "no-magic-numbers": 1, //没有魔鬼数字 "prefer-const": 0, //首选const "no-const-assign": 2, //禁止修改const声明的变量 "no-redeclare": 1, //禁止重复声明变量 "no-undef": 2, //变量未定义 "no-unused-vars": 1, "no-unused-vars": [1, &#123; "vars": "all", "args": "after-used" &#125;], //不能有声明后未被使用的变量或参数 "no-use-before-define": 2, //未定义前不能使用 "camelcase": 1, //驼峰命名法 "newline-before-return": 1, //return前需要空行 "no-constant-condition": 2, //禁止在条件中使用常量表达式 if(true) if(1) "no-debugger": 2, //禁止使用debugger "no-dupe-keys": 2, //在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125; "no-dupe-args": 2, //函数参数不能重复 "no-duplicate-case": 2, //switch中的case标签不能重复 "no-trailing-spaces": 1, //一行结束后面不要有空格 "no-unreachable": 2, //不能有无法执行的代码 "no-unused-expressions": 2, //禁止无用的表达式 "curly": [2, "all"], //必须使用 if()&#123;&#125; 中的&#123;&#125; "space-before-blocks": [0, "always"], //不以新行开始的块&#123;前面要不要有空格 "no-sparse-arrays": 2, //数组中多出逗号 "no-shadow-restricted-names": 2, //关键词与命名冲突 "no-mixed-spaces-and-tabs": 1, "no-irregular-whitespace": 1 &#125;&#125;; 本站访客数: 本站总访问量次]]></content>
  </entry>
  <entry>
    <title><![CDATA[myNote]]></title>
    <url>%2F2018%2F05%2F01%2FmyNote%2F</url>
    <content type="text"><![CDATA[笔记而已 网站 正则匹配 http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html 跨域 https://zhuanlan.zhihu.com/p/25778815?group_id=825753774160252928 bind、apply、call https://blog.csdn.net/u014267183/article/details/52610600 https://blog.csdn.net/A_dangdang/article/details/50986168 typings安装、cnpm安装 https://www.cnblogs.com/IPrograming/archive/2016/04/30/VsCodeTypings.html ESlint https://www.cnblogs.com/IPrograming/p/VsCodeESLint.html Promise讲解 https://www.cnblogs.com/lvdabao/p/es6-promise-1.html async/await https://www.cnblogs.com/kazetotori/p/6043983.html async、await获取电影海报http://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6 代码热更新 https://cnodejs.org/topic/5977fe1068aa87c774e5ebf2 通过插件实现代码热更新https://www.cnblogs.com/benpaodexiaopangzi/p/5856642.html http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/ 搭建博客 https://www.zhihu.com/question/20962496 https://www.ezlippi.com/blog/2015/03/github-pages-blog.html https://www.jianshu.com/p/834d7cc0668d https://hexo.io/zh-cn/docs/ https://www.jianshu.com/p/d1fdf3316fc0 获取github.io的iphttps://jingyan.baidu.com/article/3c343ff70fb6e60d3779632f.html aliyun https://dc.console.aliyun.com/next/index#/domain/list/all-domain https://help.aliyun.com/knowledge_detail/39783.html?spm=5176.200122.n2.4.lB9Hsw zhanghao:hanfengleigithub/hanfengleixxxxxxxxxxxxxxxxxxxx1039 https://www.jianshu.com/p/3217ecf4a789 hexo d 失败 https://www.cnblogs.com/xsilence/p/6001938.html hexo的next主题个性设计 https://www.jianshu.com/p/f054333ac9e6 http://theme-next.iissnan.com/theme-settings.html 官方 冒泡排序： &#160; &#160; &#160; &#160;比较相邻的两个数，如果前一个数大于后一个数，就将这两个数换位置。每一次遍历都会将本次遍历最大的数冒泡到最后。&#160; &#160; &#160; &#160;为了将n个数排好序，需要n-1次遍历。 如果某次遍历中，没有调整任何两个相邻的数的位置关系，说明此时数组已排好序，可以结束程序。123456789101112131415161718Array.prototype.bubbleSort = function () &#123; let i, j; for (i = 1; i &lt; this.length; i++) &#123; //表示本次是第i次遍历 let changed = false; for (j = 0; j &lt; this.length - i; j++) &#123; //访问序列为arr[0:length-i] if (this[j] &gt; this[j + 1]) &#123; //发现前一个数大于后一个时，互换位置 [this[j], this[j + 1]] = [this[j + 1], this[j]]; changed = true; &#125; &#125; if (!changed) &#123; //如果本轮遍历没有发现位置调整，结束排序函数 break; &#125; &#125;&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.bubbleSort();console.log(arr); 选择排序: &#160; &#160; &#160; &#160;第i轮便利, 选出arr[0:n-i]中最大的数, 与arr[n-i]互换12345678910111213141516Array.prototype.selectSort = function () &#123; let i, j; for (i = 1; i &lt; this.length; i++) &#123; //表示本次是第i次遍历 let maxIndex = 0; for (j = 0; j &lt;= this.length - i; j++) &#123; //访问子序列为arr[0:this.length-i] if (this[j] &gt; this[maxIndex]) &#123; //当前值大于当前最大值时，记录索引 maxIndex = j; &#125; &#125; //将子数组最大值索引的值，与子数组末尾的值互换 [this[this.length - i], this[maxIndex]] = [this[maxIndex], this[this.length - i]] &#125;&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.selectSort();console.log(arr); 插入排序: &#160; &#160; &#160; &#160;数组的前面部分已经排好序，要把当前数字插入到前面已排好序的数组的相应位置。&#160; &#160; &#160; &#160;可能有人会有疑问为什么默认数组前面部分已排好序？是怎么排好序的？是因为当排序开始时，从第2个数字开始进行向前插入，此时当前数字索引为1，当前数字前面仅有一个数字，因此可以认为前面部分已经排好序，将这个数字插入到相应位置之后数组仍然是有序的。每次都将当前数字插入到对应的位置，因此每次插入之后前面的数组仍是排好序的。12345678910111213141516171819Array.prototype.insertSort = function () &#123; let i, j; for (i = 1; i &lt; this.length; i++) &#123; //i表示当前要向前插入的数字的索引，从1(即第2个数)开始前插 let val = this[i]; //记录当前要前插的数的大小 /* * 用指针j来遍历第i个数字前面的，已经排好序的子数组。当j没有指到头，并且j的数字大于要插入的数字时，说明 * j还要向前遍历，直到发现一个比要插入数字小的位置pos，然后将这个数字插到pos+1处。如果j已经指到头了， * 到了-1了还没有找到比当前数字小的位置，就把当前数字放在索引0处。 * for (j = i - 1; j &gt;= 0 &amp;&amp; this[j] &gt; val; j--) &#123; this[j + 1] = this[j]; &#125; this[j + 1] = val; &#125;&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.insertSort();console.log(arr); shell排序 &#160; &#160; &#160; &#160;shell排序 加了step的插入排序。分别以索引数为0,1,……step-1的元素为起点，将其看做不同的组，0、0+step、0+2step、……、0+nstep为一组，1、1+step、1+2step、…..、1+nstep为一组依次分组，按照组为单位进行插入排序。各组都已经插入排序一轮过后，将step除以2向下取整，再进行分组并将各组分别进行插入排序，直到step为0。 step的取值与性能直接相关，需要思考后取值。 并且这里的分组仅仅是逻辑上分组，并没有开辟新的地址空间将其进行物理上的分组。12345678910111213141516171819202122232425262728const &#123; floor&#125; = Math;//这个和插入排序相同，只不过加了stepArray.prototype.shellInsertSort = function (startIndex, step) &#123; let i, j; for (i = startIndex + step; i &lt; this.length; i += step) &#123; let val = this[i]; for (j = i - step; j &gt;= 0 &amp;&amp; this[j] &gt; val; j -= step) &#123; this[j + step] = this[j]; &#125; this[j + step] = val; &#125;&#125;;Array.prototype.shellSort = function () &#123; let i, step; for (step = floor(this.length / 2); step &gt; 0; step = floor(step / 2)) &#123; for (i = 0; i &lt; step; i++) &#123; this.shellInsertSort(i, step); &#125; &#125;&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.shellSort(true);console.log(arr); 合并排序 &#160; &#160; &#160; &#160;举个例子： 有 43 12 32 29 66 78 31这个数组要用合并排序。 先将相邻两数分为一组进行合并 43|12 32|29 66|78 31 结果为12 43 29 32 66 78 31再将组的大小乘以二 (12 43|29 32) (66 78|31) 本次合并后结果为 12 29 32 43 31 66 78，再将组的大小乘以二 12 43 29 32 | 66 78 31 合并结果：12 29 31 32 43 66 78，合并的过程中要开辟新的数组arr，建立两个指针i,j分别指向arr1与arr2，此时arr1与arr2都是排好序的，然后每次都将arr1[i]与arr2[j]较小的数加到arr中并将指针后移。最后哪个数组有剩余的数在追加到arr后面。123456789101112131415161718192021222324252627282930313233const &#123; min&#125; = Math;function merge(arr1, arr2, ) &#123; let arr = []; let i = 0, j = 0; while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123; arr1[i] &lt; arr2[j] ? arr.push(arr1[i++]) : arr.push(arr2[j++]); &#125; return i &lt; arr1.length ? arr.concat(arr1.slice(i)) : arr.concat(arr2.slice(j))&#125;Array.prototype.mergeSort = function () &#123; let groupSize, i, secondPartSize, firstPart, secondPart, totalSize; //最初合并时，每组的大小仅为1，然后将组的大小乘以2。 for (groupSize = 1; groupSize &lt; this.length; groupSize *= 2) &#123; for (i = 0; i &lt; this.length; i += 2 * groupSize) &#123; //前半段大小一定是groupSize，后半段则不一定 secondPartSize = min(groupSize, this.length - i - groupSize); totalSize = secondPartSize + groupSize; //截取前后部分数组，将其排序 firstPart = this.slice(i, i + groupSize); secondPart = this.slice(i + groupSize, i + groupSize + secondPartSize); this.splice(i, totalSize, ...merge(firstPart, secondPart)); &#125; &#125;&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.mergeSort();console.log(arr); 合并排序: &#160; &#160; &#160; &#160;举个例子： 有 43 12 32 29 66 78 31这个数组要用合并排序。 先将相邻两数分为一组进行合并 43|12 32|29 66|78 31 结果为12 43 29 32 66 78 31，再将组的大小乘以二 (12 43|29 32) (66 78|31) 本次合并后结果为 12 29 32 43 31 66 78，再将组的大小乘以二 12 43 29 32 | 66 78 31 合并结果：12 29 31 32 43 66 78，合并的过程中要开辟新的数组arr，建立两个指针i,j分别指向arr1与arr2，此时arr1与arr2都是排好序的，然后每次都将arr1[i]与arr2[j]较小的数加到arr中并将指针后移。最后哪个数组有剩余的数在追加到arr后面。123456789101112131415161718192021222324252627282930313233const &#123; min&#125; = Math;function merge(arr1, arr2, ) &#123; let arr = []; let i = 0, j = 0; while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123; arr1[i] &lt; arr2[j] ? arr.push(arr1[i++]) : arr.push(arr2[j++]); &#125; return i &lt; arr1.length ? arr.concat(arr1.slice(i)) : arr.concat(arr2.slice(j))&#125;Array.prototype.mergeSort = function () &#123; let groupSize, i, secondPartSize, firstPart, secondPart, totalSize; //最初合并时，每组的大小仅为1，然后将组的大小乘以2。 for (groupSize = 1; groupSize &lt; this.length; groupSize *= 2) &#123; for (i = 0; i &lt; this.length; i += 2 * groupSize) &#123; //前半段大小一定是groupSize，后半段则不一定 secondPartSize = min(groupSize, this.length - i - groupSize); totalSize = secondPartSize + groupSize; //截取前后部分数组，将其排序 firstPart = this.slice(i, i + groupSize); secondPart = this.slice(i + groupSize, i + groupSize + secondPartSize); this.splice(i, totalSize, ...merge(firstPart, secondPart)); &#125; &#125;&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.mergeSort();console.log(arr); 自然合并排序 &#160; &#160; &#160; &#160;合并排序的分组是死板的没有利用到数组中原本就是顺序的子序列。如果数组为 43 56 79 12 33 90 66 将其分组为 43 56 79 | 12 33 90 | 66 再将相邻的，原本就是从小到大的顺序的数组进行合并，效果会更好。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function merge(arr1, arr2) &#123; let arr = [], i = 0, j = 0; while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123; arr.push(arr1[i] &lt; arr2[j] ? arr1[i++] : arr2[j++]) &#125; return arr.concat(i &lt; arr1.length ? arr1.slice(i) : arr2.slice(j));&#125;function getSortedArrList(arr) &#123; //记录下已经原本就是从小到大顺序的子数组 let sortedArrList = []; let childArr = [arr[0]]; for (let i = 1; i &lt; arr.length; i++) &#123; //当前值小于上一个值时，将childArr加入sortedArrList中，创建新的childArr，并加入当前值。 if (arr[i] &lt; arr[i - 1]) &#123; sortedArrList.push(childArr); childArr = [arr[i]]; &#125; //否则，将当前值加入到childArr中 else &#123; childArr.push(arr[i]); &#125; &#125; sortedArrList.push(childArr); return sortedArrList;&#125;Array.prototype.naturalMergeSort = function () &#123; let sortedArrList = getSortedArrList(this); //获取原本从小到大顺序的子数组 while (sortedArrList.length &gt; 1) &#123; //当还有两个及以上的数组没合并完成时 let newSortedArrList = []; for (let i = 0; i &lt; sortedArrList.length; i += 2) &#123; if (i !== sortedArrList.length - 1) &#123; newSortedArrList.push(merge(sortedArrList[i], sortedArrList[i + 1])); &#125; else &#123; newSortedArrList.push(sortedArrList[i]); &#125; &#125; sortedArrList = newSortedArrList; &#125; this.splice(0, this.length, ...sortedArrList[0]);&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.naturalMergeSort();console.log(arr); 基数排序(LSD least significant digit first) &#160; &#160; &#160; &#160;LSD中没有数值之间的比较。建立一个[10][]的二维数组arr。挑选出要排序数组中最大的数字，计算该数字的位数记为digitNum。将数组中的所有数字填充到digitNum位，位数不够的高位补0。然后遍历digitNum次，从低位开始。第i次遍历按照将数组中元素的第i位的数值，将元素num放到二维数组相应位置处，如果num第i位数值为n，则执行arr[n].push(num)的操作。每次遍历之后，将arr[0:9]各数组的元素依次取出，并且重新初始化二维数组。直到遍历到最高位为止，再取出的就是已经排好序的。123456789101112131415161718192021222324252627282930313233343536const &#123; max&#125; = Math;function initBarrel() &#123; let barrel = []; for (let i = 0; i &lt; 10; i++) &#123; barrel[i] = []; &#125; return barrel;&#125;function radixSort(arr) &#123; let barrel = initBarrel(); let figureNum = max(...arr).toString().length; //计算最大的数字的位数 arr = arr.map(num =&gt; num.toString().padStart(figureNum, '0')); //将数字填充到figureNum位 for (let i = 0; i &lt; figureNum; i++) &#123; let index = figureNum - i - 1; //本次根据第index位来选择放入哪个桶 arr.forEach(numStr =&gt; &#123; //将填充过的数组放入桶中 let num = Number(numStr[index]); barrel[num].push(numStr); &#125;); arr = barrel.reduce((prevArr, curArr) =&gt; prevArr.concat(curArr), []); //汇总barrel中的数 barrel = initBarrel(); //初始化barrel &#125; return arr.map(num =&gt; Number(num)); //最终转为数字形式&#125;Array.prototype.radixSort = function () &#123; let arr = radixSort(this); this.splice(0, this.length, ...arr);&#125;;let arr = [1234342, 52165, 75, 1, 356, 575, 765433212, 57994, 3535];arr.radixSort();console.log(arr); 基数排序(MSD most significant digit first) 从高位开始，依然没有数值之间的比较。 &#160; &#160; &#160; &#160;将最初的元素序列按照各元素最高位的数值进行分组，将分组后，组中只有一个元素或者多个相等元素的组拼接到result数组中，而有多个不同元素的组再递归地向下分，取的位次依次减少。12345678910111213141516171819202122232425262728293031323334353637383940414243444546const &#123; max&#125; = Math;function initBarrel() &#123; let barrel = []; for (let i = 0; i &lt; 10; i++) &#123; barrel[i] = []; &#125; return barrel;&#125;//判断当前桶中是否只有唯一值 有的桶中可能只有一种值，但是有多个重复项function unique(barrel) &#123; return new Set(barrel).size &lt;= 1;&#125;Array.prototype.radixSort = function () &#123; let result = []; let figureNum = max(...this).toString().length; this.splice(0, this.length, ...this.map(num =&gt; num.toString().padStart(figureNum, '0'))); radixGroup(this, 0, figureNum, result); this.splice(0, this.length, ...result.map(numStr =&gt; Number(numStr)));&#125;;function radixGroup(group, index, figureNum, result) &#123; //输入的group是一组numStr，index是当前分桶依据第几位数 if (index &lt; figureNum) &#123; let barrel = initBarrel(); group.forEach(numStr =&gt; &#123; let idx = Number(numStr[index]); barrel[idx].push(numStr); &#125;); barrel.forEach(subBarrel =&gt; &#123; if (unique(subBarrel)) &#123; subBarrel.forEach(num =&gt; &#123; result.push(num); &#125;) &#125; else &#123; radixGroup(subBarrel, index + 1, figureNum, result); &#125; &#125;) &#125;&#125;let arr = [1234342, 52165, 75, 1, 356, 575, 765433212, 57994, 3535];arr.radixSort();console.log(arr); 快速排序 &#160; &#160; &#160; &#160;将数组头部的元素pivotNum作为一个基准，通过两个指针指向数组的头部和尾部，经过一次partition以后将pivotNum放在一个位置pivot，pivot前面的数小于pivotNum，后面的数大于pivotNum。 为了防止最坏情况的发生，可以在数组中随机选出一个数来与数组头部元素换位置，来降低具体实例与最坏情况的关联性。1234567891011121314151617181920212223242526272829303132333435363738const &#123; floor, random&#125; = Math;function randomIndex(start, end) &#123; return floor(random() * (end - start + 1)) + start;&#125;function partition(arr, start, end) &#123; let index = randomIndex(start, end); [arr[start], arr[index]] = [arr[index], arr[start]]; let value = arr[start]; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; arr[end] &gt; value) end--; arr[start] = arr[end]; while (start &lt; end &amp;&amp; arr[start] &lt; value) start++; arr[end] = arr[start]; &#125; arr[start] = value; return start;&#125;function quickSort(arr, start, end) &#123; if (start &lt; end) &#123; let pivot = partition(arr, start, end); quickSort(arr, start, pivot - 1); quickSort(arr, pivot + 1, end); &#125;&#125;Array.prototype.quickSort = function (asc = true) &#123; quickSort(this, 0, this.length - 1, asc)&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.quickSort();console.log(arr); 堆排序 &#160; &#160; &#160; &#160;将数组看做完全二叉树，因此节点i的左右子节点的索引分别为2i+1与2i+2。通过从根节点开始令小的值下沉，或者从最后的叶节点开始令大的值上浮的方法，将一个数组构造成一个大根堆。再将大根堆的头元素与尾元素换位置，这样就将当前最大值置换到了尾部。然后下次构建大根堆的时候，将刚置换过的尾部元素刨除在外不做为节点。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const &#123; floor, max&#125; = Math;function getBiggestNodeIndex(...nodes) &#123; return nodes.indexOf(max(...nodes));&#125;//将arr从0开始，长度为length的子数组构建为堆function constructHeap(arr, length) &#123; let adjusted = true; //adjusted来标识本次堆是否作出了调整，若未调整说明堆已构建完毕 while (adjusted) &#123; adjusted = false; for (let i = 0; i &lt; floor(length / 2); i++) &#123; //当只有左节点时 if (2 * i + 2 === length) &#123; //当父节点比左节点小的时候 if (arr[i] &lt; arr[2 * i + 1]) &#123; //互换 [arr[i], arr[2 * i + 1]] = [arr[2 * i + 1], arr[i]]; adjusted = true; &#125; &#125; //当同时有左节点和右节点时 else &#123; //判断三个中最大的节点 let biggestNodeIndex = getBiggestNodeIndex(arr[i], arr[2 * i + 1], arr[2 * i + 2]); //若父节点不是最大的，则和最大的交换 //如果biggestNodeIndex为0，说明自己最大，为1，说明左节点大，为2，说明右节点大 switch (biggestNodeIndex) &#123; case 0: break; case 1: [arr[i], arr[2 * i + 1]] = [arr[2 * i + 1], arr[i]]; adjusted = true; break; case 2: [arr[i], arr[2 * i + 2]] = [arr[2 * i + 2], arr[i]]; adjusted = true; break; &#125; &#125; &#125; &#125;&#125;function heepSort(arr) &#123; //只将arr从0开始，长度为length的子数组构建成大根堆 let length = arr.length; while (length &gt; 1) &#123; constructHeap(arr, length); [arr[0], arr[length-- - 1]] = [arr[length - 1], arr[0]]; &#125;&#125;Array.prototype.heepSort = function () &#123; heepSort(this);&#125;;let arr = [43, 21, 10, 5, 9, 15, 32, 57, 35];arr.heepSort();console.log(arr); 计算字符串长度1234567891011function chkstrlen(str) &#123; var strlen = 0; for (var i = 0; i &lt; str.length; i++) &#123; if (str.charCodeAt(i) &gt; 255) &#123; strlen += 2; &#125; else &#123; strlen++; &#125; &#125; return strlen;&#125; js中, 类型的相互转换 1, 对象布尔值 对象: 先转换为字符串,然后字符串转换为数字, 布尔值: 转换为数字 2, 对象字符串 对象: 转为字符串 3, 对象数字 对象: 先转为字符串, 再转为数字 4, 字符串数字 字符串: 转为数字 5, 字符串布尔值 二者全都转为数字 6, 布尔值数字 布尔值: 转为数字 比较规则:1234567对象 \ \ 字符串 布尔值 \ / \ / 数字 如果不是同一类型比较: 对象–&gt;字符串–&gt;数值 布尔值–&gt;数值 特殊: undefined == null // true, undefined和null,与其他值比较都是false undefined === null // false 比较两个数组是否相同1234567891011function equalArrays(a, b) &#123; if (a.length != b.length) &#123; return false; &#125; for (var i = 0; i &lt; a.length; i++) &#123; if (a[i] !== b[i]) &#123; return false; &#125; &#125; return true;&#125; 删除数组中指定”变量”的成员1234567891011121314151617Array.prototype.indexOf = function (val) &#123; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] == val) &#123; return i; &#125; &#125; return -1;&#125;Array.prototype.remove = function (val) &#123; var index = this.indexOf(val); if (index &gt; -1) &#123; This.splice(index, 1); &#125;&#125;var arr = [1, 2, 333, 4, 5];arr.remove(333); 常见浅拷贝12345678910111213function shallowCopy(obj) &#123; if (typeof obj !== 'object') &#123; return; &#125; // var newObj = obj instanceof Array ? [] : &#123;&#125;; var newObj = Object.prototype.toString.call(arr) === '[Object Array]' ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] == obj[key]; &#125; &#125; return newObj;&#125; 为什么需要child-process? node是异步非阻塞的，这对高并发非常有效．可是我们还有其它一些常用需求，比如和操作系统shell命令交互，调用可执行文件，创建子进进行阻塞式访问或高CPU计算等，child-process就是为满足这些需求而生的 fs.watch和fs.watchFile有什么区别，怎么应用? 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统， 但是相比fs.watch有些慢，因为不是实时机制． express response有哪些常用方法 res.end() 结束responseres.download()弹出文件下载res.json()返回jsonres.jsonp()返回jsonpres.redirect（）重定向请求res.send()返回多种形式的数据res.sendFile（）返回文件res.sendStatus()返回状态 apache,nginx有什么区别? 二者都是代理服务器，功能类似．apache应用简单，相当广泛．nginx在分布式，静态转发方面比较有优势． nodejs优缺点：nodejs优点 1，nodejs是基于时间驱动和无阻塞的，非常适合处理并发请求2，与nodejs代理服务器交互的客户端代码是由js语言编写， 客户端和服务端采用一种语言编写 nodejs缺点 &#160; &#160; &#160; &#160;1，node技术是一个相对新的开源项目， 不太稳定，变化速度快2，不适合cpu密集应用，如果有长时间运行的计算，将会导致cpu时间片不能释放，使得后续的I/O无法发起 nodejs适用场景 高并发，聊天，实时消息推送 npm是什么npm是nodejs包管理和分发的工具，用于管理node包，如：安装、卸载、发布、查看等 npm好处 npm可以安装、管理项目的依赖，且可以指明依赖项目的具体版本 设么是前后端分离 大家一致认同的前后端分离的例子就是SPA(Single-page application)，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。 SPA式的前后端分离，是从物理层做区分(认为只要是客户端的就是前端，服务器端的就是后端)， 这种分法已经无法满足我们前后端分离的需求，我们认为从职责上划分才能满足目前我们的使用场景：前端：负责View和Controller层。后端：只负责Model层，业务处理/数据等。 什么是错误优先的回调函数？ 错误优先的回调函数(Error-First Callback)用于同时返回错误和数据。第一个参数返回错误，并且验证它是否出错；其他参数用于返回数据。 async/await简介 async/await是写异步代码的新方式，以前的方法有回调函数和Promise。async/await是基于Promise实现的，它不能用于普通的回调函数。async/await与Promise一样，是非阻塞的。async/await使得异步代码看起来像同步代码，这正是它的魔力所在。 本站访客数: 本站总访问量次]]></content>
  </entry>
  <entry>
    <title><![CDATA[本地数据丢失后如何更新博客]]></title>
    <url>%2F2018%2F05%2F01%2F%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E5%90%8E%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本地数据丢失后如何更新博客 博客搭建流程 创建仓库，hanfenglei1039.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:hanfenglei1039/hanfenglei1039.github.io.git拷贝仓库； 在本地hanfenglei1039.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo generate -d生成网站并部署到GitHub上。这样一来，在GitHub上的hanfenglei1039.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 日常修改在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 依次执行 git add . git commit -m “…” git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行 hexo generate -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，调转顺序就有问题了）。 本地数据丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:hanfenglei1039/hanfenglei1039.github.io.git拷贝仓库（默认分支为hexo）；在本地新拷贝的hanfenglei1039.github.io文件夹下通过Git bash依次执行下列指令： npm install hexo npm install npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 本站访客数: 本站总访问量次]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub分支操作]]></title>
    <url>%2F2018%2F05%2F01%2FGitHub%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[github分支操作 首先需要当前目录设置为仓库目录创建本地分支1.查看有哪些分支：git branch 1.创建一个分支：git branch name ，其中name是分支名 1.切换到分支：git checkout name 说明：可以将2和3合起来操作，创建+切换分支：git checkout -b name 下面就可以在当前分支上进行相关的文件操作了。 注意，如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。 提交分支到github服务器git push origin name 说明：分支提交到服务器上后，如果在本地对分支进行变更后，同样可以执行该操作，将变更信息更新到github的分支上。 将分支的更新内容合并到master分支切换到master分支， git checkout master 合并name分支到当前mater分支：git merge name 注意：这时合并到master上内容还没有提交到github上，需要push操作。 删除分支删除本地分支：git branch -d name 删除服务器上的分支：git push origin :name (分支名前的冒号代表删除) clone分支克隆github上的仓库到本地，默认会把仓库的所有内容clone到本地。 但只会在本地默认创建一个master分支。这时需要用 git branch -r 才能看到所有分支名字。 这时用 git checkout 分支名 操作就把远程分支取到本地。 这时再用不带-r的git branch命令就能看到刚才操作的分支名了。 本站访客数: 本站总访问量次]]></content>
  </entry>
</search>
